\section{Our Approach}

\subsection{Core Pig Latin Features}
\begin{frame}{Core Pig Features}
\begin{itemize}
	\item \textbf{Programs specify queries over relations:} Designed to
	concisely facilitate common data transformation tasks.
	\item \textbf{Programs manipulate aggregate non-atomic types:} e.g. bags
	and tuples.
	\item \textbf{Programs use UDFs from environment.}
	\item \textbf{Programs specify data flow via statements:} A sequence of
	statements define dependencies between queries via var assignments and uses.
	\item \textbf{Programs are parallelizable/distributable:} Part of a long
	history in data flow and query-oriented programming.
\end{itemize}
\end{frame}

\subsection{Formalism}
\begin{frame}{Conventions}
\centering
	\begin{flushleft}
		T : a type\newline
		S : a type that satisfies schema type\newline
		c : an integer to denote column offset\newline
		x, y : identifiers\newline
		\textGamma \: : Context\newline
 		s : a statement\newline
 		q : a term of query form\newline 
	\end{flushleft}
\end{frame}

\begin{frame}{Grammar: Schema Types}
\centering
	\begin{flushleft}
	$ \texttt{schema} := \hfill \texttt{Schema Types}\hfill$\\
	$ \quad \mid \texttt{STNil}\hfill \texttt{{Unit Type}}\hfill$\\
   	$ \quad \mid \texttt{STConsInt} \hfill \texttt{Function Type}\hfill$\\
    $ \quad \mid \texttt{STConsBag} \hfill \texttt{Predicate Type}\hfill$\\
	\end{flushleft}
\end{frame}

\begin{frame}{Grammar: UDF Types}
\centering
	\begin{flushleft}
	$ \texttt{udf} := \hfill \texttt{User Defined Types}\hfill$\\
	$ \quad \mid \texttt{UDFTFn}\hfill \texttt{UDF Function Type}\hfill$\\
   	$ \quad \mid \texttt{UDFTPred} \hfill \texttt{UDF Predicate Type}\hfill$\\
	\end{flushleft}
\end{frame}

\begin{frame}{Grammar: Loadable Types}
\centering
	\begin{flushleft}
	$ \texttt{loadable\_ty} \::= \hfill \texttt{Loadable Types}\hfill$\\
	$ \quad \mid \texttt{LTSchema}\hfill \texttt{Loadable Schema}\hfill$\\
   	$ \quad \mid \texttt{LTUDF} \hfill \texttt{Loadable UDF}\hfill$\\
	\end{flushleft}
\end{frame}

\begin{frame}{Grammar: Terms For Logical Plan}
\centering
	\begin{flushleft}
	$ \texttt{tm} := \hfill \texttt{Terms}\hfill$\\
	$ \quad \mid \texttt{t\_filter}\hfill \texttt{Query Filter}\hfill$\\
   	$ \quad \mid \texttt{t\_foreach} \hfill \texttt{Query ForEach}\hfill$\\
    $ \quad \mid \texttt{t\_group} \hfill \texttt{Query Group}\hfill$\\
    $ \quad \mid \texttt{t\_join} \hfill \texttt{Query Join}\hfill$\\
    $ \quad \mid \texttt{t\_load} \hfill \texttt{Load Statement}\hfill$\\
   	$ \quad \mid \texttt{t\_assign} \hfill \texttt{Assignment Statement}\hfill$\\
    $ \quad \mid \texttt{t\_seq} \hfill \texttt{Sequence of Statements}\hfill$\\
    $ \quad \mid \texttt{t\_store} \hfill \texttt{Store Statement}\hfill$\\
	\end{flushleft}
\end{frame}

\begin{frame}{Grammar: Types}
\centering
	\begin{flushleft}
	$ \texttt{ty} := \hfill \texttt{Types}\hfill$\\
	$ \quad \mid \texttt{TUnit}\hfill \texttt{Unit Type}\hfill$\\
   	$ \quad \mid \texttt{TFn} \hfill \texttt{Function Type}\hfill$\\
    $ \quad \mid \texttt{TPred} \hfill \texttt{Predicate Type}\hfill$\\
    $ \quad \mid \texttt{TNil} \hfill \texttt{Schema Tuple Terminator}\hfill$\\
    $ \quad \mid \texttt{TCons} \hfill \texttt{Schema Tuple Extension}\hfill$\\
   	$ \quad \mid \texttt{TInt} \hfill \texttt{Atomic Schema Attribute}\hfill$\\
    $ \quad \mid \texttt{TBag} \hfill \texttt{Compound Schema Attribute}\hfill$\\
	\end{flushleft}
\end{frame}

\subsection{Typing Rules for Logical Plan}
\begin{frame}{Typing Rules: Queries}
	\begin{mathpar}
		\inferrule* [Right=\texttt{T\_Filter}]
          		{\Gamma \vdash \texttt{x = S} \\ \texttt{schema \:S} \\ 
          		\Gamma \vdash \texttt{y = Pred \:S}} 
          		{\Gamma \vdash \texttt{FILTER \:x, y} \in \texttt{S} }
		\hva \and
		\inferrule* [Right={\textbf{T\_ForEach}}]
          		{schema \:S_1 \\ schema \:S_2 \\\\ 
				\Gamma \vdash x = S_1 \\ \Gamma \vdash y = Fn\: S_1\:S_2} 
				{\Gamma \vdash FOREACH \:x\:y \in S }
	\end{mathpar}
\end{frame}

\begin{frame}{Typing Rules: Queries(continued...)}
	\begin{mathpar}
		\inferrule* [Right=\textbf{T\_Group}]
          		{\Gamma \vdash x = S \\\\ 
          		schema \:S \\ schema \:S' \\\\ 
          		schema\_column\_has\_type \:S \:c \\\\ 
          		S' = TInt ::: (TBag \:S)} 
          		{\Gamma \vdash GROUP \:x \:c \in S' }
	\end{mathpar}
\end{frame}

\begin{frame}{Typing Rules: Queries(continued...)}
	\begin{mathpar}
		\inferrule* [Right=\textbf{T\_Join}]
          		{\Gamma \vdash x = S_1 \\ \Gamma \vdash y =  S_2 \\\\
          		schema\:S_1 \\ schema \:S_2 \\\\ 
		 		schema\_column\_has\_type \:S_1 \:c_x \\\\
		 		schema\_column\_has\_type \:S_2 \:c_y \\\\
		 		concatenated\_schema \:S_1\:S_2\:S_3} 
		 		{\Gamma \vdash JOIN \:x \:c_x \:y \:c_y \in S_3 }
	\end{mathpar}
\end{frame}

\begin{frame}{Typing Rules: Statements}
\centering
	\begin{mathpar}
		\inferrule* [Right=\textbf{T\_Load}]
          		{\Gamma \vdash x = None \\ loadable\_ty\: T} 
          		{\Gamma \vdash LOAD \:x\:T \in TUnit }
		\hva \and
		\inferrule* [Right=\textbf{T\_Assign}]
          		{\Gamma \vdash x = None \\ \Gamma \vdash q = S \\schema \:S} 
          		{\Gamma \vdash ASSIGN \:x \:q \in TUnit }
		\hva \and
		\inferrule* [Right=\textbf{T\_Store}]
				{\Gamma \vdash x = S \\ schema \:S} 
				{\Gamma \vdash STORE \:x \in TUnit }
	\end{mathpar}
\end{frame}

\begin{frame}{Typing Rules: Statements (continued...)}
	\begin{mathpar}
		\inferrule* [Right=\textbf{T\_SeqLoad}]
          		{s_1 = LOAD \:x \:T \\ \Gamma \vdash s_1 \in TUnit \\\\
          		\Gamma, x:T \vdash s_2 \in TUnit } 
          		{\Gamma \vdash SEQ \:s_1 \:s_2 \in TUnit }
          		
		\hva \and
		\inferrule* [Right=\textbf{T\_SeqAssign}]
          		{s_1 = ASSIGN \:x \:q \\\\
          		\Gamma \vdash q = S \\ schema \:S \\\\
          		\Gamma \vdash s_1 \in TUnit \\ \Gamma, x:S \vdash s_2 \in TUnit} 
          		{\Gamma \vdash SEQ \:s_1 \:s_2 \in TUnit }
	\end{mathpar}
\end{frame}

\begin{frame}{Typing Rules: Statements (continued...)}
	\begin{mathpar}
		\inferrule* [Right= \textbf{T\_SeqStore}]
          	{s_1 = STORE \:x \\\\
          	\Gamma \vdash x = S \\ schema \:S  \\\\ 
			\Gamma \vdash s_1 \in TUnit \\ \Gamma \vdash s_2 \in TUnit } 
			{\Gamma \vdash SEQ \:s_1 \:s_2 \in TUnit }
	\end{mathpar}
\end{frame}